#!/bin/bash


## Progress
function echo_progress() {
  echo -e "`mytimestamp` - $*"
}

## Success
function echo_success() {
  echo -e "$GREEN`mytimestamp` - $*"
}

## Failure
function echo_failure() {
  echo -e "$RED`mytimestamp` - $*"
}


# Simple calculator
function calc() {
  local result="";
  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
  #                       â””â”€ default (when `--mathlib` is used) is 20
  #
  if [[ "$result" == *.* ]]; then
    # improve the output for decimal numbers
    printf "$result" |
    sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
        -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
        -e 's/0*$//;s/\.$//';  # remove trailing zeros
  else
    printf "$result";
  fi;
  printf "\n";
}

# Reload Chrome via OSA
# more info: https://developer.apple.com/library/mac/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html
function reload-chrome() {
  osascript -e '
  tell application "Google Chrome"
      tell the active tab of its first window
          reload
      end tell
  end tell
  '
}



# Word frequency
function wordFreq() {
  ruby -F'[^a-zA-Z]+' -ane '
      BEGIN   { $words = Hash.new(0) }
      $F.each { |word| $words[word.downcase] += 1 }
      END     { $words.each { |word, i| printf "%3d %s\n", i, word } }
  ' | sort -rn

}

# Change the bash title
function title {
    if [ "$1" ]
    then
        unset PROMPT_COMMAND
        echo -ne "\033]0;${*}\007"
    else
        export PROMPT_COMMAND='echo -ne "\033]0;${PWD/#$HOME/~}\007"'
    fi
}

# get a random word from the system dictionary.
function randomWord() {
  resource=/usr/share/dict/words;
  lineNum=$(cat $resource | wc -l);
  cat -n $resource | grep -w $(jot -r 1 1 $lineNum) | cut -f2;
}

#get a random line of a file
function randomLine() {
     randomFile="head -$((${RANDOM} % `wc -l < $1` + 1)) $1"
     echo `$randomFile | tail -1`
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Pub key send
function pubkeysend() {
  ssh-copy-id -i ~/.ssh/id_rsa.pub $1
}

# SSH + CD
function sshcd() {
  ssh -t $1 "cd $2; bash"
}

# Search and Replace based on the params
function srall {
    find . -type f -exec sed -i '' s/$1/$2/g {} +
}

# Search and Replace based on params - with extension
function srext {
    find . -type f -name '*.$1' -exec sed -i '' s/$2/$3/g {} +
}

# Filter Specific column
function col {
  awk -v col=$1 '{print $col}'
}

# Skip X words in line
function skip {
    n=$(($1 + 1))
    cut -d' ' -f$n-
}

# Change working directory to the top-most Finder window location
function cdfinder() { # cdf
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
  local tmpFile="${@%/}.tar";
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
  );

  local cmd="";
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli";
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz";
    else
      cmd="gzip";
    fi;
  fi;

  echo "Compressing .tar using \`${cmd}\`â€¦";
  "${cmd}" -v "${tmpFile}" || return 1;
  [ -f "${tmpFile}" ] && rm "${tmpFile}";
  echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* ./*;
  fi;
}


## find which pid is listening on port
function portuse {
  lsof -n -i4TCP:"$@" | grep LISTEN
}

# Use Gitâ€™s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@";
  }
fi;

# Create a data URL from a file
function dataurl() {
  local mimeType=$(file -b --mime-type "$1");
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8";
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Create a git.io short URL
function gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    echo "Usage: \`gitio slug url\`";
    return 1;
  fi;
  curl -i https://git.io/ -F "url=${2}" -F "code=${1}";
}

# Start an HTTP server from a directory, optionally specifying the port
function pythonserver() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
  local port="${1:-4000}";
  local ip=${2:-$(ipconfig getifaddr en0)};
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}";
}

# Compare original and gzipped file size
function gz() {
  local origsize=$(wc -c < "$1");
  local gzipsize=$(gzip -c "$1" | wc -c);
  local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
  printf "orig: %d bytes\n" "$origsize";
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
#python -c "import json,sys; print json.dumps(json.load(sys.stdin),indent=4,separators=(',',': '))"
function json() {
  jsonnocolor | pygmentize -l javascript;
}
function jsonnocolor() {
  if [ -t 0 ]; then # argument
    python -mjson.tool <<< "$*"
  else # pipe
    python -mjson.tool
  fi;
}


# bsh
function bsh() {
  java -cp .:/usr/local/bin/bsh.jar bsh.Interpreter $*
}

# xml format
function xmlformat() {
  xmllint --format -
}



# Trim spaces
function trim () {
  while read -r line; do echo "$line"; done;
}

# Run `dig` and display the most useful info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer;
}

# UTF-8-encode a string of Unicode symbols
function escape() {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
  # print a newline unless weâ€™re piping the output to another program
  if [ -t 1 ]; then
    echo ""; # newline
  fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
  # print a newline unless weâ€™re piping the output to another program
  if [ -t 1 ]; then
    echo ""; # newline
  fi;
}

# Get a characterâ€™s Unicode code point
function codepoint() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))";
  # print a newline unless weâ€™re piping the output to another program
  if [ -t 1 ]; then
    echo ""; # newline
  fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified.";
    return 1;
  fi;

  local domain="${1}";
  echo "Testing ${domain}â€¦";
  echo ""; # newline

  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
    | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    local certText=$(echo "${tmp}" \
      | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
      no_serial, no_sigdump, no_signame, no_validity, no_version");
    echo "Common Name:";
    echo ""; # newline
    echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
    echo ""; # newline
    echo "Subject Alternative Name(s):";
    echo ""; # newline
    echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
      | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
    return 0;
  else
    echo "ERROR: Certificate not found.";
    return 1;
  fi;
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
function s() {
  if [ $# -eq 0 ]; then
    subl .;
  else
    subl "$@";
  fi;
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
function a() {
  if [ $# -eq 0 ]; then
    atom .;
  else
    atom "$@";
  fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
function v() {
  if [ $# -eq 0 ]; then
    vim .;
  else
    vim "$@";
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .;
  else
    open "$@";
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


# whois a domain or a URL
function whois() {
  local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
  if [ -z $domain ] ; then
    domain=$1
  fi
  echo "Getting whois record for: $domain â€¦"

  # avoid recursion
          # this is the best whois server
                          # strip extra fluff
  /usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}

function localip(){
  function _localip(){ echo "ðŸ“¶ - "$(ipconfig getifaddr "$1"); }
  export -f _localip
  local purple="\x1B\[35m" reset="\x1B\[m"
  networksetup -listallhardwareports | \
    sed -r "s/Hardware Port: (.*)/${purple}\1${reset}/g" | \
    sed -r "s/Device: (en.*)$/_localip \1/e" | \
    sed -r "s/Ethernet Address:/ðŸ“˜ /g" | \
    sed -r "s/(VLAN Configurations)|==*//g"
}


# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
  if [ -f "$1" ] ; then
    local filename=$(basename "$1")
    local foldername="${filename%%.*}"
    local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
    local didfolderexist=false
    if [ -d "$foldername" ]; then
      didfolderexist=true
      read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
      echo
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        return
      fi
    fi
    mkdir -p "$foldername" && cd "$foldername"
    case $1 in
      *.tar.bz2) tar xjf "$fullpath" ;;
      *.tar.gz) tar xzf "$fullpath" ;;
      *.tar.xz) tar Jxvf "$fullpath" ;;
      *.tar.Z) tar xzf "$fullpath" ;;
      *.tar) tar xf "$fullpath" ;;
      *.taz) tar xzf "$fullpath" ;;
      *.tb2) tar xjf "$fullpath" ;;
      *.tbz) tar xjf "$fullpath" ;;
      *.tbz2) tar xjf "$fullpath" ;;
      *.tgz) tar xzf "$fullpath" ;;
      *.txz) tar Jxvf "$fullpath" ;;
      *.zip) unzip "$fullpath" ;;
      *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}





# Add reminder to Reminders.app (OS X 10.8)
# Usage: `remind 'foo'` or `echo 'foo' | remind`
function remind () {
  local text
  if [ -t 0 ]; then
    text="$1" # argument
  else
    text=$(cat) # pipe
  fi
  osascript >/dev/null <<EOF
tell application "Reminders"
  tell the default list
    make new reminder with properties {name:"$text"}
  end tell
end tell
EOF
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'title' 'body'` or `echo 'body' | note`
# Title is optional
function note () {
  local title
  local body
  if [ -t 0 ]; then
    title="$1"
    body="$2"
  else
    title=$(cat)
  fi
  osascript >/dev/null <<EOF
tell application "Notes"
  tell account "iCloud"
    tell folder "Notes"
      make new note with properties {name:"$title", body:"$title" & "<br><br>" & "$body"}
    end tell
  end tell
end tell
EOF
}


# Top 10 BASH commands used
# from stackoverflow.com/questions/68372/what-is-your-single-most-favorite-command-line-trick-using-bash#answer-68390
function top10 () {
    history | awk 'BEGIN {FS="[ \t]+|\\|"} {print $3}' | sort | uniq -c | sort -nr | head
}

# Copy w/ progress
function cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}



# Read JSON Tag
function jsontag() {
  python -c $'
import json,sys;
obj=json.load(sys.stdin);
result=obj["'"$1"'"];

if isinstance(result, unicode):
  print result;
else:
  print json.dumps(result, indent=4);
  ';
}

# Read JSON Index
function jsonindex() {
  python -c $'
import json,sys;
obj=json.load(sys.stdin);
result=obj['"$1"'];

if isinstance(result, unicode):
  print result;
else:
  print json.dumps(result, indent=4);
  ';
}


# Read JSON Val in Array
function jsonarrayval() {
  python -c $'
import json,sys;
obj=json.load(sys.stdin);

for inst in (item for item in obj):
  if "'$1'" in inst:
    result = inst["'$1'"]
    if isinstance(result, unicode):
      print result;
    else:
      print json.dumps(result, indent=4);
  ';
}

function paramtest() {
echo "First: $1";
echo "Second: ${*:2}";

}

#Get my timestamp
function mytimestamp() {
  date +"%Y-%m-%d %T"
}


#Requote
#https://stackoverflow.com/questions/3260920/preserving-quotes-in-bash-function-parameters
function requote() {
  local res=""
  for x in "${@}" ; do
    # try to figure out if quoting was required for the $x:
    grep -q "[[:space:]]" <<< "$x" && res="${res} '${x}'" || res="${res} ${x}"
  done
  # remove first space and print:
  sed -e 's/^ //' <<< "${res}"
}

#Build Jenkins and wait until finished
function jenkinsbuildandwait() {

  echo "`mytimestamp` - Building $1";


  if [ $# -eq 2 ]; then
    curl -v -X POST "$1/build?delay=0sec" -H 'Content-Type: application/x-www-form-urlencoded' --data "$2"
  else
    curl -v -X POST "$1/buildWithParameters"
  fi


  sleep 10

  url="$1/lastBuild/api/json"
  lastBuildResult=$(curl -s "$url" | jsontag result)
  while [ "$lastBuildResult" != "SUCCESS" ];
  do
  echo "`mytimestamp` - Waiting for $1 to complete (result: $lastBuildResult)";
  sleep 10

  lastBuildResult=$(curl -s "$url" | jsontag result)

  done

  echo "`mytimestamp` - Finished $1!";

}



#Random say voice
function sayrandomvoice() {
  declare -a expressions=('Agnes' 'Kathy' 'Princess' 'Vicki' 'Victoria' 'Alex' 'Bruce' 'Fred' 'Junior' 'Ralph' 'Albert' 'Bad News' 'Bahh' 'Bells' 'Boing' 'Bubbles' 'Cellos' 'Deranged' 'Good News' 'Hysterical' 'Pipe Organ' 'Trinoids' 'Whisper' 'Zarvox');
  index=$( jot -r 1  0 $((${#expressions[@]} - 1)) )
  say -v "${expressions[index]}" $*
}


## Echo Jump Dir
function jecho() {

  echo "$(j $* | nocolor)";

}

## No colors. :)
function nocolor() {
  sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | sed "s/\x0f//g"
}

##kill processes with name
function grepkill() {
    ps aux | grep -ie "$2" | grep -v "grep" | awk '{print $2}' | xargs kill $1
}



##sort by timestamp alphabetically
function sortbytimestamp() {

  for fi in `ls -1 | grep -v ".txt"`
  do
    echo "Touch $fi..."
    touch $fi
    sleep 0.2
  done
}


# ScreenShot
function ss() {
  echo "[ss - press space to select rectangle]"
  if [ "$1" != "" ]; then
    screencapture -iW $*
  else
    #clipboard
    screencapture -ciW
  fi
}

# Dotfile Backup
function dotbkp() {
  if [ ! -d ~/Dropbox/dotfiles ]; then
    echo "Not allowed in this machine."
    return
  fi

  rsync -ruv --exclude '.git' ~/githubworkspace/dotfiles/ ~/Dropbox/dotfiles/
  rm -rf ~/Dropbox/dotfiles/.git
  scp ~/githubworkspace/dotfiles/.priv8functions bruno@california:~/githubworkspace/dotfiles/
}


# Safari tools
function safariurl() {
  osascript -e 'tell application "Safari" to get URL of current tab of front window'
}
function safarisource() {
  osascript -e 'tell application "Safari" to get source of current tab of front window'
}
function safaritext() {
  osascript -e 'tell application "Safari" to get text of current tab of front window'
}

#Chrome tools
function chromeurl() {
  osascript -e 'tell app "Google Chrome" to URL of active tab of window 1'
}

# list selected finder files
function finderselected() {
  osascript <<EOT
      tell application "Finder"
          set theFiles to selection
          set theList to ""
          repeat with aFile in theFiles
              set theList to theList & POSIX path of (aFile as alias) & "\n"
          end repeat
          theList
      end tell
EOT
}




function regex1 {
  gawk 'match($0,/'$1'/, ary) { print ary['${2:-'1'}'] }';
}



function __git_dirty {
  git diff --quiet HEAD &>/dev/null
  [ $? == 1 ] && echo "!"
}

function mybranch {
  __git_ps1 "%s"
}

function __git_branch {
  __git_ps1 "[%s]"
}
